# Exercise 1: Hello World
## 1.1 Thinking about elevators
TODO.
> Brainstorm some techniques you could use to prevent Sverre from being hopelessly stranded, waiting for an elevator that will never arrive. Think about the worst-case behavior of the system.

* What if the software controlling one of the elevators suddenly crashes?
* What if it doesn't crash, but hangs?
* What if a message between machines is lost?
* What if the network cable is suddenly disconnected? Then re-connected?
* What if a user of the system is being a troll?
* What if the elevator car never arrives at its destination?

## 1.2 Set up source control and build tools
✅ Done.

## 1.3 Reasons for concurrency and parallelism
### What is concurrency? What is parallelism? What's the difference?
.

### Why have machines become increasingly multicore in the past decade?
.

### What kinds of problems motivates the need for concurrent execution? (Or phrased differently: What problems do concurrency help in solving?)
.

### Does creating concurrent programs make the programmer's life easier? Harder? Maybe both? (Come back to this after you have worked on part 4 of this exercise)
.

### What are the differences between processes, threads, green threads, and coroutines?
.

### Which one of these do pthread_create() (C/POSIX), threading.Thread() (Python), go (Go) create?
.

### How does pythons Global Interpreter Lock (GIL) influence the way a python Thread behaves?
.

### With this in mind: What is the workaround for the GIL (Hint: it's another module)?
.

### What does `func GOMAXPROCS(n int) int` change?
.

## 1.4
The two threads compute `i = i ± 1`. The value of `i` will be "cached" during the computation, and the threads will get out of sync over time. Therefore, the result of the computation is a random value that is wrong.
